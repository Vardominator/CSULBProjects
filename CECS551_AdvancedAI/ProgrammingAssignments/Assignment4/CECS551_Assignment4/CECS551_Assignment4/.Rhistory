install.packages("e1071")
source("F:/GitHub/CSULBProjects/CECS551_AdvancedAI/ProgrammingAssignments/Assignment4/CECS551_Assignment4/CECS551_Assignment4/script.R", encoding = "Windows-1252")
accuracies_table <- accuracies_table[order(Degree, -Cost),]
accuracies_table <- accuracies_table[order("Degre", -"Cost"),]
acc
accuracies_table
current_model <- svm(Rings ~ ., data = abalone_df, kernel = "polynomial", degree = 6, type = "C-classification", cost = 1, cross = cross_fold)
print(current_model)
current_model$tot.accuracy
current_model <- svm(Rings ~ ., data = abalone_df, kernel = "polynomial", degree = 4, type = "C-classification", cost = 10, cross = cross_fold)
print(current_model$tot.accuracy)
current_model <- svm(Rings ~ ., data = abalone_df, kernel = "polynomial", degree = 4, type = "C-classification", cost = 1, cross = cross_fold)
print(current_model$tot.accuracy)
accuracies_table
accuracies_table <- accuracies_table[order(-Cost),]
accuracies_table <- accuracies_table[order(-accuracies_table$Cost),]
accuracies_table
max_combination <- accuracies_table[which.max(accuracies_table$Degree, accuracies_table$Accuracy),]
max_combination <- accuracies_table[which.max(accuracies_table$Degree, -accuracies_table$Accuracy),]
max_combination <- accuracies_table[which.max( - accuracies_table$Accuracy),]
accuracies_table
max_combination <- accuracies_table[which.max( - accuracies_table$Accuracy),]
max_combination <- max_combination[which.max(max_combination$Degree),]
max_combination
max_combination <- accuracies_table[which.max( -accuracies_table$Accuracy),]
max_combination
accuracies_table
accuracies_table <- accuracies_table[order(-accuracies_table$Cost),]
accuracies_table <- accuracies_table[order(accuracies_table$Degree),]
print(accuracies_table)
max_combination <- accuracies_table[which.max(accuracies_table$Accuracy),]
max_combination
degrees <- c(1:3)
costs <- c(10 ^ (-1:2))
degrees
costs
degrees <- c(1:3)
costs <- c(10 ^ (-1:2))
cross_fold <- 5
best_accuracy <- 0
# For each combination perform: 10-fold cross validation and training accuracy from training over the entire data set
accuracies_table <- data.frame("Degree" = integer(), "Cost" = integer(), "Accuracy" = numeric(), stringsAsFactors = FALSE)
for (d in degrees) {
    for (c in costs) {
        current_model <- svm(Rings ~ ., data = abalone_df, kernel = "polynomial", degree = d, type = "C-classification", cost = c, cross = cross_fold)
        accuracies_table[nrow(accuracies_table) + 1, ] <- c(d, c, current_model$tot.accuracy)
    }
}
accuracies_table <- accuracies_table[order(-accuracies_table$Cost),]
accuracies_table <- accuracies_table[order(accuracies_table$Degree),]
accuracies_table
max_combination <- accuracies_table[which.max(accuracies_table$Accuracy),]
degrees <- c(1:3)
costs <- c(10 ^ (-1:2))
cross_fold <- 5
best_accuracy <- 0
best_predictions
# For each combination perform: 5-fold cross validation and training accuracy from training over the entire data set
accuracies_table <- data.frame("Degree" = integer(), "Cost" = integer(), "Accuracy" = numeric(), stringsAsFactors = FALSE)
for (d in degrees) {
    for (c in costs) {
        current_model <- svm(Rings ~ ., data = abalone_df, kernel = "polynomial", degree = d, type = "C-classification", cost = c, cross = cross_fold)
        accuracies_table[nrow(accuracies_table) + 1, ] <- c(d, c, current_model$tot.accuracy)
        if (current_model$tot.accuracy > best_accuracy) {
            best_accuracy <- current_model$tot.accuracy
            best_predictions <- predict(current_model, abalone_df[,-length(abalone_df)])
        }
    }
}
# SORT BY INCREASING COMPLEXITY
accuracies_table <- accuracies_table[order(-accuracies_table$Cost),]
accuracies_table <- accuracies_table[order(accuracies_table$Degree),]
# combination with the highest accuracy
max_combination <- accuracies_table[which.max(accuracies_table$Accuracy),]
source("F:/GitHub/CSULBProjects/CECS551_AdvancedAI/ProgrammingAssignments/Assignment4/CECS551_Assignment4/CECS551_Assignment4/script.R", encoding = "Windows-1252")
best_predictions
average_distance <- abs(best_predictions - abalone_df$Rings)
length(best_predictions)
length(abalone_df$Rings)
best_predictions[10]
print(best_predictions[10])
print(abalone_df$Rings[10])
class(best_predictions)
class(abalone_df$Rings)
best_predictions <- as.numeric(levels(best_predictions)[best_predictions])
class(best_predictions)
best_predictions <- as.integer(levels(best_predictions)[best_predictions])
class(best_predictions)
class(abalone_df$Rings)
average_distance <- abs(best_predictions - abalone_df$Rings)
average_distance
best_predictions - abalone_df$Rings
print(best_predictions - abalone_df$Rings)
length(best_predictions)
for (d in degrees) {
    for (c in costs) {
        current_model <- svm(Rings ~ ., data = abalone_df, kernel = "polynomial", degree = d, type = "C-classification", cost = c, cross = cross_fold)
        accuracies_table[nrow(accuracies_table) + 1, ] <- c(d, c, current_model$tot.accuracy)
        if (current_model$tot.accuracy > best_accuracy) {
            best_accuracy <- current_model$tot.accuracy
            best_predictions <- predict(current_model, abalone_df[,-length(abalone_df)])
        }
    }
}
# SORT BY INCREASING COMPLEXITY
accuracies_table <- accuracies_table[order(-accuracies_table$Cost),]
accuracies_table <- accuracies_table[order(accuracies_table$Degree),]
# combination with the highest accuracy
max_combination <- accuracies_table[which.max(accuracies_table$Accuracy),]
source("F:/GitHub/CSULBProjects/CECS551_AdvancedAI/ProgrammingAssignments/Assignment4/CECS551_Assignment4/CECS551_Assignment4/script.R", encoding = "Windows-1252")
best_pred_int <- as.integer(best_predictions)
best_pred_int
best_predictions
average_distance <- abs(best_predictions - abalone_df$Rings)
class(best_pred_int)
class(abalone_df$Rings)
average_distance <- best_predictions - abalone_df$Rings
average_distance <- (best_predictions - abalone_df$Rings)
average_distance
type(best_pred_int)
as.type(best_pred_int))
as.type(best_pred_int)
average_distance <- (best_pred_int - abalone_df$Rings)
average_distance
average_distance <- abs(best_pred_int - abalone_df$Rings)
average_distance <- mean(abs(best_pred_int - abalone_df$Rings))
average_distance
class_distance <- abs(best_pred_int - abalone_df$Rings)
average_distance <- mean(class_distance)
average_distance <- mean(class_distance)
class_distance <- abs(best_pred_int - abalone_df$Rings)
class_distances <- abs(best_pred_int - abalone_df$Rings)
class_distances
hist(class_distances)
install.packages("ggplot2")
library(ggplot)
library(ggplot2)
ggplot(class_distances) +  geom_histogram(filled.contour="white", color="black") +  geom_vline(aes(xintercept=mean(class_distances)), color="blue", linetype="dashed") +  labs(title="True-Predicted Distance Histogram", x="Class Distances", y="Frequency") +  theme_classic()
ggplot(as.numeric(class_distances)) +  geom_histogram(filled.contour="white", color="black") +  geom_vline(aes(xintercept=mean(class_distances)), color="blue", linetype="dashed") +  labs(title="True-Predicted Distance Histogram", x="Class Distances", y="Frequency") +  theme_classic()
ggplot(as.data.frame(class_distances)) +  geom_histogram(filled.contour="white", color="black") +  geom_vline(aes(xintercept=mean(class_distances)), color="blue", linetype="dashed") +  labs(title="True-Predicted Distance Histogram", x="Class Distances", y="Frequency") +  theme_classic()
ggplot(as.data.frame(class_distances)) +  geom_histogram(fill="white", color="black") +  geom_vline(aes(xintercept=mean(class_distances)), color="blue", linetype="dashed") +  labs(title="True-Predicted Distance Histogram", x="Class Distances", y="Frequency") +  theme_classic()
hist(class_distances)
